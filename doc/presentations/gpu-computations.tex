\documentclass{article}
%\usepackage{authblk}
\usepackage{amssymb, amsmath}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{multirow}

\addtolength{\hoffset}{-3.5cm}
\addtolength{\textwidth}{6.8cm}
\addtolength{\voffset}{-3cm}
\addtolength{\textheight}{6cm}

%\author[1]{Todor Milev}
%\affil[1]{FA Enterprise System}
\title{
OpenCL cryptographic computations \\
for FAB coin
}
\author{Todor Milev\footnote{FA Enterprise System}\\ todor@fa.biz}
\newcommand{\secpTwoFiveSixKone}{{\bf secp256k1}}
\renewcommand{\mod}{{~\bf mod~}}
\begin{document}
\maketitle
\section{Introduction}
Public/private key cryptography is arguably the most important aspect of modern crypto-currency systems. The somewhat slow execution of private/public key cryptography algorithms appears to be one of the main bottlenecks of FAB's Kanban system. 

In the present text we describe our port of the cryptographic functions that make up the computational core of fabcoin to the GPU programming language OpenCL. Whether this port is to be used in the final version of Kanban - as opposed to using directly the original fabcoin/bitcoin cryptopgrahic library from which the port was derived - remains to be decided.

\subsection{Findings of our investigation}
[Coming soon]

%Our investigation of the feasibility of running cryptography using OpenCL, and using the GPU in general, remain inconclusive. Our initial findings suggest that, without any hardware-specific optimization, the CPU performs considerably better than the GPU - anywhere from three to five times better on the hardware combinations we tested.  Here, we must stress that under OpenCL, GPU and CPU computations can be ran in parallel within the same run-time, without the need to recompile or launch multiple executables. 

%However, online sources such as Nvidia's guide \cite{NVIDIA:openCLBestPractices} suggest that custom-tailored software optimizations may (or may not) yield between 4- and 10- fold speed optimizations on Nvidia hardware, depending on the particular device and program type, see \cite[page 22]{NVIDIA:openCLBestPractices}. As CPUs appear to be less amenable to software optimizations, it remains feasible that a GPU may outperform a CPU of a similar class, should a considerable effort be put into software optimizations. 

%Even without such optimizations, OpenCL remains a reasonable option as it allows the same code to run on both the CPU and on multiple GPUs (without the need of much engineering), effectively adding the speeds of all involved devices. 

%However, at present we cannot recommend switching over to using OpenCL... [to be continued].

\subsection{OpenCL vs CUDA}
[Coming soon]
%We also considered CUDA (an Nvidia proprietary language), but - for the time being - chose to use OpenCL instead as that allows the use of AMD GPUs, Intel system-on-chip GPUs and, last but not least, the Intel/AMD CPUs running the host system. In addition, the use of OpenCL should allow for future ports to the upcoming Intel GPUs \cite{forbes:IntelGPUupcoming}. 

%While our primary reason for choosing OpenCL over CUDA was hardware portability and the ability to run code on the CPU, our decision was partially supported by the ambiguous studies of the performance of OpenCL vs CUDA. For example, \cite{KarimiEtAl:DBLP:CUDAvsOpenCL} reports between 13\% and 63\% slower performance of OpenCL vs CUDA, however \cite{MemetiLPKK17:CUDAvsOpenCL:DBLP:journals/corr} reports a slightly better performance of OpenCL vs CUDA. These reports do appear to depend heavily on the particular benchmark used. Even assuming the most pessimistic estimate of 63\% slower performance of OpenCL, the ability to run our software on the CPU and non-Nvidia hardware appears to be a reasonable trade-off. 

%We must mention that, in support of CUDA over OpenCL, Jason Hong from FA System has informally reported much better performance on SHA256 computations when using CUDA - up to 7-fold increase of performance. The huge differences in speed reported internally may be a function of CUDA-specific code optimizations or a function of the specifics of SHA256 computations. Further investigation into the matter is required. Whether the performance of the other cryptographic functions will be closer to Jason's experience or to the benchmarks reported in \cite{KarimiEtAl:DBLP:CUDAvsOpenCL}, \cite{MemetiLPKK17:CUDAvsOpenCL:DBLP:journals/corr} remains to be investigated.

%Our choice of OpenCL has not been finalized yet; whether we switch to CUDA or to another parallel computation framework remains to be decided.


\subsection{Benchmarks}

Speed. All tabulated devices ran the same code. With the exception of a small header file (27 lines for OpenCL and 67 lines for C++), the code is both valid OpenCL and valid C/C++. The total code size is, at the time of writing, 7153 lines of code (= 5049 actual lines + 1294 comments + 810 blank) in a total of 22 files.


\begin{tabular}{lll}
Name & Description & Function name (look in kanban/opencl/ ... )\\
mine SHA256$^{\circ2}$& vary input of  $\text{SHA256}(\text{SHA256}(x))$, fetch best\\
\end{tabular}

\noindent\begin{tabular}{|p{5.5cm}|l|r|r||r|r|r|}\hline
Device & run-time &mine SHA256$^{\circ2}$& SHA256 & Pub. key & Sign & Verification\\\hline
Nvidia Quadro K2000 (2 computational units) & OpenCL 1.1 & &19,007/sec & 171/sec & 121/sec & 66/sec\\\hline
\multirow{2}{*}{ \shortstack{
Intel${}^{\text{\sffamily\textregistered}}$ Xeon${}^{\text{\sffamily\textregistered}}$ CPU\\ E5-2630 @ 2.60GHz (12 cores)
}} & OpenCL 1.2 &5.98 million/sec &96,028/sec & 2,063/sec& 1,044/sec & 639/sec\\\cline{2-7}
& C++ std::thread& & 36,040/sec&13,937/sec&6,471/sec&5,505/sec \\\hline\hline
Intel${}^{\text{\sffamily\textregistered}}$ HD Graphics (SOC, see next) @ 1.1Ghz Intel${}^{\text{\sffamily\textregistered}}$ (23 computational units) & OpenCL 2.0& & 55,769/sec& N/A & N/A& N/A \\\hline
\multirow{2}{*}{\shortstack{
Intel${}^{\text{\sffamily\textregistered}}$ Core${}^{\text{\sffamily\texttrademark}}$ CPU \\
i5-8250U @ 1.6Ghz (8 cores)
}} & OpenCL 2.0 & &130,844/sec& 1,765/sec &1,018/sec& 533/sec\\\cline{2-7}
&C++ std::thread&  &48,865/sec& 13,643/sec&5,961/sec&4,136/sec \\\hline\hline
Nvidia GeForce GTX 1080 @1.86Ghz (20 computational units)&OpenCL 1.2& &34,967/sec&N/A&N/A&N/A\\\hline

Radeon${}^{\text{\sffamily\texttrademark}}$ RX 480 Graphics @1266 Mhz &OpenCL 1.2&  &31,621/sec& N/A & N/A& N/A
\\\hline

\multirow{2}{*}{\shortstack{
Intel${}^{\text{\sffamily\textregistered}}$ Core${}^{\text{\sffamily\texttrademark}}$ CPU \\ i5-7600 @ 3.50GHz (4 cores)
}} 
&OpenCL 2.0&  &237,161/sec & 1,497/sec & 2,592/sec&  856/sec\\\cline{2-6}
&C++ std::thread &&84,259/sec&21,719/sec&6,930/sec&5,093/sec\\\hline
\end{tabular}



Compilation times. Measures the difficulty of testing code changes.

\noindent\begin{tabular}{|p{5cm}|l|r||r|r|r|r|}\hline
Device & run-time & SHA256 & init& Pub. key & Sign & Verification\\\hline
Nvidia Quadro K2000 & OpenCL 1.1 &0.5 sec& 23.3 sec &3.5 sec &6.1 sec &11.5 sec\\\hline 
Intel${}^{\text{\sffamily\textregistered}}$ Xeon${}^{\text{\sffamily\textregistered}}$ CPU E5-2630 @ 2.60GHz (12 cores)&  OpenCL 1.2&0.1 sec&379.2 sec&147.7 sec&360.3 sec&362.6 sec\\\hline \hline
Intel${}^{\text{\sffamily\textregistered}}$ HD Graphics (SOC, see next) @ 1.1Ghz Intel${}^{\text{\sffamily\textregistered}}$ (23 computational units)& OpenCL 2.0& 0.3 sec &69.4 sec &2.8 sec&19.3 sec   & 39.9 sec	 \\\hline
Intel${}^{\text{\sffamily\textregistered}}$ Core${}^{\text{\sffamily\texttrademark}}$ CPU 
i5-8250U @ 1.6Ghz (8 cores)& OpenCL 2.0&0.1 sec&417.7 sec &154.5 sec &382.6 sec &379.8 sec \\\hline\hline 
Radeon${}^{\text{\sffamily\texttrademark}}$ RX 480 Graphics @1266 Mhz &OpenCL 1.2&0.2 sec  &45.1 sec &1.9 sec&11.3 sec&23.9 sec \\\hline 
Intel${}^{\text{\sffamily\textregistered}}$ Core${}^{\text{\sffamily\texttrademark}}$ CPU i5-7600 @ 3.50GHz (4 cores)&OpenCL 2.0&0.1 sec&234.7 sec&90.8 sec&235.0 sec&232.4 sec \\\hline
\end{tabular}


\subsection{The four main cryptographic functions} \label{sectionFourMainCrypto}
The four main cryptographic functions used to run FAB coin (and all other major crypto-currencies, powered by various algorithms) are as follows.
\begin{enumerate}
\item \label{enumFourMainSHA} Secure hashing function.
\item \label{enumFourMainPrivatePublicKeyGeneration} Private/public key pair generation.
\item \label{enumFourMainCryptoSignature} Cryptographic signature.
\item \label{enumFourMainVerification} Cryptographic signature verification.
\end{enumerate}

\noindent\ref{enumFourMainSHA}) Among many secure hashing functions, FAB uses SHA256 (secure hash algorithm 2, 256 bit). The same algorithm is also used in bitcoin. The secure hash is used to digest messages into 256 bit = 32 byte lengths. SHA256 has the property that, given a message and its digest, it is practically impossible to forge another message that has the same digest. 
%Likewise, given a digest alone, it is practically impossible to guess a message that it came from - or even prove that a message exists. 
In this way, SHA256 can be reliably used to identify data. 

\noindent\ref{enumFourMainPrivatePublicKeyGeneration}) Private keys are kept secret and are used to sign data - most importantly, transactions/transfers of funds. The public key is a function of the private key that is published openly alongside a message that may or may not be signed with the private key. 

Private/public key pairs have the property that, given a message, a signature and a public key, everyone can verify that the signature was correctly generated with an unknown private key that matches the known public key, but no one can guess the private key from which the signature and the public key were generated. Furthermore, given a message, no one can generate a signature matching a given public key without knowing the secret private key that corresponds to it.

The main use case of private/public key pairs is as follows. A message - say, a statement of transfer of funds - is published in the open. To consent with the transfer, the original owner of the funds produces the cryptographic signature of the transfer message. Since the original owner's public key is published in the open and is therefore known, everyone can verify the correctness of this transfer, but only the original owner can generate it.

\noindent\ref{enumFourMainCryptoSignature}) Cryptographic signatures are used to sign messages using private keys as described in \ref{enumFourMainPrivatePublicKeyGeneration}). Among many cryptographic schemes for signing messages, FAB coin uses the industry standard ECDSA (Elliptic Curve Digital Signature Algorithm) over the elliptic curve \secpTwoFiveSixKone, see Section \ref{sectionECDSAgeneral}. This is the same algorithm stack as the one used in bitcoin.

The cryptographic signature is a function of the message being signed, the private key, and, in the particular case of (EC)DSA, a one-time use random number.

\noindent\ref{enumFourMainVerification}) The signature verification algorithm is used to verify signatures generated as described in \ref{enumFourMainPrivatePublicKeyGeneration}). The signature verification is a function of the signed message, the signature, and the public key of the signature owner.

\subsection{ECDSA}\label{sectionECDSAgeneral}
Following Bitcoin, FAB coin uses the standard public/private key cryptography ECDSA over \secpTwoFiveSixKone. Here, ECDSA stands for Elliptic Curve Digital Signature Algorithm and \secpTwoFiveSixKone{} stands for the elliptic curve:

\[
y^2 = x^3 + 7
\]
(we do not specify the base point here), over the finite field:

\[
\mathbb Z / p\mathbb Z, 
\]
where
\begin{equation}\label{eqThePrime}
p= 2^{256} - 2^{32} - 977.
\end{equation}

At present, fabcoin core uses bitcoin's implementation of \secpTwoFiveSixKone{}. We report here that we ported one of bitcoin's development forks - Pieter Wuille's C project libsecp256k1 \cite{Wuille:secp256k1}  - to OpenCL. This development branch was chosen as our base as it is also the base of the top-google-search (partial) OpenCL port \cite{secp256k1:openCLimplementationHanh0}. We did not choose to use \cite{secp256k1:openCLimplementationHanh0} directly as the port appeared to not be self-contained and contained only an implementation of the signature verification function \ref{enumFourMainVerification})  from Section \ref{sectionFourMainCrypto}.


\bibliographystyle{plain}
\bibliography{../bibliography}
\end{document}
